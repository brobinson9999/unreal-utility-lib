class DynamicArrayEventQueue extends EventQueue;

// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  var array<QueuedEvent> events;

//  var float lastDebugTime;
//  simulated function runEventsTo(float endTime) {
//    if (endTime - lastDebugTime > 5) {
//      lastDebugTime = endTime;
//      debugMSG("event queue:");
//      debugPrintEventQueue();
//    }
//      
//    super.runEventsTo(endTime);
//  }
//
//  simulated function QueuedEvent setupEvent(float time, BaseObject callbackTarget) {
//    local int eventsLength;
//    local QueuedEvent result;
//    
//    eventsLength = events.length;
//    result = super.setupEvent(time, callbackTarget);
//    myAssert(eventsLength == events.length-1, "DynamicArrayEventQueue.setupEvent: adding event increased events.length by 1");
//    return result;
//  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  // ambiguous if two events have the same time...
  simulated function int findIndexForTime(float time) {
    local int low, high, mid;
    local float midTime;
    
    low = 0;
    high = events.length - 1;
    
    while (low <= high) {
      mid = (low + high) / 2;
      midTime = events[mid].time;
      if (midTime < time)
        low = mid + 1;
      else if (midTime > time)
        high = mid - 1;
      else
        return mid;
    }
    
    return low;
  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  // If multiple events have the same time, the more recently added should go at the end.
  simulated function int findInsertionIndexForTime(float time) {
    local int index;
    
    index = findIndexForTime(time);
    while (index < events.length && events[index].time <= time)
      index++;
    
    return index;
  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  // Find a matching time, then scan forward and backward to find the event.
  simulated function int findIndexForExistingEvent(QueuedEvent existingEvent) {
    local int startIndex, cursorIndex;
    local float existingEventTime;
    
    existingEventTime = existingEvent.time;
    
    startIndex = findIndexForTime(existingEventTime);
    cursorIndex = startIndex;
    while (cursorIndex >= 0 && cursorIndex < events.length && events[cursorIndex].time == existingEventTime) {
      if (events[cursorIndex] == existingEvent)
        return cursorIndex;
      
      cursorIndex--;
    }

    cursorIndex = startIndex;
    while (cursorIndex < events.length && events[cursorIndex].time == existingEventTime) {
      if (events[cursorIndex] == existingEvent)
        return cursorIndex;

      cursorIndex++;
    }
    
    return -1;
  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  simulated function queueEvent(QueuedEvent thisEvent)
  {
    local int insertionIndex;
    
    insertionIndex = findInsertionIndexForTime(thisEvent.time);
    
    if (insertionIndex < events.length)
      events.insert(insertionIndex, 1);
      
    events[insertionIndex] = thisEvent;
  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  simulated function removeEvent(QueuedEvent oldEvent)
  {
    local int eventIndex;
    
    eventIndex = findIndexForExistingEvent(oldEvent);
    if (eventIndex != -1)
      events.remove(eventIndex, 1);
      
//    debugMSG("removeEvent "$oldEvent);
    recycleEvent(oldEvent);
  }

// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  simulated function QueuedEvent getNextEvent() {
    if (events.length == 0)
      return none;
    else
      return events[0];
  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  simulated function removeNextEvent() {
    if (events.length > 0) {
//      debugMSG("removeNextEvent "$events[0]);
      events.remove(0,1);
    }
  }

// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  simulated function int getLength() {
    return events.length;
  }

// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  simulated function cleanup()
  {
    while (events.length > 0) {
      events[0].cleanup();
      events.remove(0,1);
    }
    
    super.cleanup();
  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

  simulated function debugCheckEventQueue() {
    local int i;
    
    // Check for elements in the wrong order.
    for (i=1;i<events.length;i++) {
      if (events[i-1].time > events[i].time) {
        errorMessage("error: event queue has added elements in the wrong order!");
        debugPrintEventQueue();
      }
    }
    
    // Check for elements with no callback target.
    for (i=1;i<events.length;i++) {
      if (events[i-1].callBackTarget == none) {
        errorMessage("error: event queue has element with no callback target!");
        debugPrintEventQueue();
      }
    }
  }

  simulated function debugPrintEventQueue() {
    local int i;
    
    for (i=0;i<events.length;i++) {
      errorMessage(i$": "$events[i].time$" :: "$events[i].callBackTarget);
    }
  }
  
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************
// ********************************************************************************************************************************************

defaultproperties
{
}